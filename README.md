# N_puzzle_Astar
**使用A\*算法求解N数码问题**

给定初始矩阵

2 1 6

4 0 8

7 5 3

与目标矩阵

1 2 3

8 0 4

7 6 5

其中0代表空格，可将数字移动到空格。

求解从初始矩阵到目标矩阵的路径。

A\*算法求解步骤：

Step1: 把初始节点S0放入OPEN表中;

Step2: 若OPEN表为空,则搜索失败,退出.

Step3: 移出OPEN中第一个节点N放入CLOSED表中, 并标以顺序号n;

Step4: 若目标节点Sg=N, 则搜索成功,结束.

Step5: 若N不可扩展, 则转Step2;

Step6: 扩展N, 生成一组子节点, 对这组子节点作如下处理后, 放入OPEN表,
按评价函数的升序重新排序OPEN表, 转Step2;

删除重复节点和修改返回指针处理.

相关知识：

OPEN表是一种动态数据结构，专门登记当前待考查（待访问）的节点，也叫未扩展节点表
。

Closed表是一种动态数据结构，记录访问过的节点，也叫已扩展节点表 ，其初始为空表。

重排OPEN表，使搜索沿某个被认为最有希望的路径扩展。

应用这种排序过程，需要某些估算节点“希望”的量度。

用来估算节点希望程度的量度，叫做估价函数（evaluation
function），有时也叫作启发函数。

用符号f来标记估价函数，用f(n)表示节点n的估价函数值。

评价函数的一般形式 : f(n) = g(n) + h(n)

g(n):从S0到Sn的实际代价(搜索的横向因子)

h(n):从N到目标节点的估计代价,称为启发函数

评价函数 f(x) = g(x) + h(x)

当f(x) = g(x) 时，为宽度优先搜索

当f(x) = 1/g(x) 时，为深度优先搜索

当f(x) = h(x) 时，为全局优先搜索

A\*算法的特征:

可采纳性:保守估计。对于树搜索,一定能找到最优解.

一致性：h(n) \<= c(n, m)+h(m) (n是m的父节点）对于图搜索,一定能找到最优解.

如果有 h1(n) \<= h2(n) \<= h\*(n), 那么h2比h1展开更少的节点.

广度优先搜索是当h(n)=0时的A\*算法的特例.

在图搜索过程中，如果重排OPEN表是依据f(x)=g(x)+h(x)进行的，则称该过程为A算法。

在A算法中，如果对所有的x存在h(x)≤h\*(x)（低估）,则称h(x)为h\*(x)的下界，它表示某种偏于保守的估计。采用h\*(x)的下界h(x)为启发函数的A算法，称为A\*算法。
